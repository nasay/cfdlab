#include "visualLB.h"
#include "computeCellValues.h"
#include "helper.h"
#include "LBDefinitions.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>


void write_vtkFile(const char *szProblem,
                   int t,
                   int * length,
                   double * collideField,
                   int * flagField) {
  
    struct stat s;
    int x, y, z, node[3];
    char szFileName[80];
    char path[80] = "vtk-output";
    // char path[80] = "vtk-output/";
    FILE *fp=NULL;
    int n[3] = { length[0] + 2,length[1] + 2,length[2] + 2 };
    double velocity[3];
    double density;
    double * el = NULL;

    if (stat(path, &s) == -1) {
        mkdir(path, 0700);
    }

    sprintf(szFileName, "%s/%s.%i.vtk", path, szProblem, t );
    fp = fopen(szFileName, "w");
    if( fp == NULL )
    {
        char szBuff[80];
        sprintf( szBuff, "Failed to open %s", szFileName );
        ERROR( szBuff );
        return;
    }

    write_vtkHeader(fp, length);
    write_vtkPointCoordinates(fp, length);

    fprintf(fp,"POINT_DATA %i \n", length[0] * length[1] * length[2]);
    fprintf(fp,"\n");
    fprintf(fp, "VECTORS velocity float\n");
    for(z = 1; z <= length[2]; z++) {
        node[2] = z;
        for(y = 1; y <= length[1]; y++) {
            node[1] = y;
            for(x = 1; x <= length[0]; x++) {
                node[0] = x;
                if (*getFlag(flagField, node, n) != OBSTACLE) {
                    el = getEl(collideField, node, 0, n);
                    computeDensity(el, &density);
                    computeVelocity(el, &density, velocity);
                    fprintf(fp, "%f %f %f\n", velocity[0], velocity[1], velocity[2]);
                } else {
                    fprintf(fp, "%f %f %f\n", 0.0, 0.0, 0.0); 
                }
            }
        }
    }

    fprintf(fp,"\n");

    fprintf(fp, "SCALARS density float 1 \n"); 
    fprintf(fp, "LOOKUP_TABLE default \n");

    for(z = 1; z <= length[2]; z++) {
        node[2] = z;
        for(y = 1; y <= length[1]; y++) {
            node[1] = y;
            for(x = 1; x <= length[0]; x++) {
                node[0] = x;
                if (*getFlag(flagField, node, n) != OBSTACLE) {
                    computeDensity(getEl(collideField, node, 0, n), &density);
                    fprintf(fp, "%f\n", density);
                } else {
                    fprintf(fp, "%f\n", 1.0);
                }
            }
        }
    }

    fprintf(fp,"\n");

    fprintf(fp, "SCALARS gas float 1 \n"); 
    fprintf(fp, "LOOKUP_TABLE default \n");

    for(z = 1; z <= length[2]; z++) {
        node[2] = z;
        for(y = 1; y <= length[1]; y++) {
            node[1] = y;
            for(x = 1; x <= length[0]; x++) {
                node[0] = x;
                if (*getFlag(flagField, node, n) == GAS) {
                    fprintf(fp, "%f\n", -1.0);
                } else {
                    fprintf(fp, "%f\n", 1.0);
                }
            }
        }
    }

    if( fclose(fp) )
    {
        char szBuff[80];
        sprintf( szBuff, "Failed to close %s", szFileName );
        ERROR( szBuff );
    }
}


void write_vtkHeader( FILE *fp, int * length) {
    if( fp == NULL ) {
        char szBuff[80];
        sprintf( szBuff, "Null pointer in write_vtkHeader" );
    
        ERROR( szBuff );
    
        return;
    }

    fprintf(fp,"# vtk DataFile Version 2.0\n");
    fprintf(fp,"generated by CFD-lab course output (written by Tobias Neckel) \n");
    fprintf(fp,"ASCII\n");
    fprintf(fp,"\n");	
    fprintf(fp,"DATASET STRUCTURED_GRID\n");
    fprintf(fp,"DIMENSIONS  %i %i %i \n", length[0], length[1], length[2]);
    fprintf(fp,"POINTS %i float\n", length[0] * length[1] * length[2]);
    fprintf(fp,"\n");
}

void write_vtkPointCoordinates(FILE *fp, int * length) {

    int x, y, z;

    for(z = 1; z <= length[2]; z++) {
        for(y = 1; y  <= length[1]; y++) {
            for(x = 1; x  <= length[0]; x++) {
                /* dx = dy = dz = 1 */
                fprintf(fp, "%d %d %d\n", x, y, z);
            }
        }
    }
}

void writeVtkOutput(double * collideField,
                    int * flagField,
                    const char * filename,
                    unsigned int t,
                    int * length) {
    write_vtkFile(filename, t, length, collideField, flagField);
}

